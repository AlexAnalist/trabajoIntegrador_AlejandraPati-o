<!DOCTYPE html>
<html>
<head>
    <title>Biblioteca</title>
</head>
<body>
    <h1>Biblioteca de Alejandr√≠a</h1>
    <script>

//Decid√≠ realizar mi trabajo practico integrador bajo el paradigma POO, ya que ha sido un paradigma con el que he trabajado con anterioridad y consider√© que el Sistema a realizar se prestaba bastante para ellos, 
//ya que pude trabajar de forma m√°s organizada luego de darle a cada clase un objetivo: Libro y Usuario son los moldes para las dos entidades m√°s importantes del programa. En biblioteca se maneja la l√≥gica principal del negocio a trav√©s de los m√©todos.
//y en la Clase Interfaz manejo la interacci√≥n de la informaci√≥n con el usuario y luego enviando a los metodos lo necesario para que ellos devuelvan lo pedido por el usuario.
//Gracias a POO, se puede organizar y reutilizar codigo, es la mejor opci√≥n en caso de que el programa quiera escalar a nuevas funcionalidades, sin contar, los beneficiosn del encapsulamiento por m√©todos.  

class Libro { //Declaramos la clase Libro
    constructor(id, titulo, autor,a√±o, genero, disponible = true){ //EL constructor con los atributos necesarios. 
        this.id = id; 
        this.titulo = titulo; 
        this.autor = autor; 
        this.a√±o = a√±o; 
        this.genero = genero; 
        this.disponible = disponible; //Por defecto se le asignara disponible a cada libro que se agregue 
    }
}

class Usuario { //Declaramos la clase usuario 
    constructor(id, nombre, email){ //El constructor con los atributos correspondientes especificados en el documento. 
        this.id = id; 
        this.nombre = nombre; 
        this.email = email; 
        this.librosPrestados = []; //A cada usuario va ligado su lista de LibrosPrestados, por lo que se declara en la clase. 
    }
}

class Biblioteca { //Declaramos la clase Biblioteca que se encargara de todas las operaciones logicas del sistema. 
    constructor(){
        this.libros = this.primerosLibros(); //inicializamos el arreglo libros(el principal del sistema) con el resultado devuelto por el metodo primerosLibros() donde se declararon los primeros 10 libros. 
        this.usuarios = this.primerosUsuarios(); //inicializamos el arreglo usuario de la misma forma que con libros. 
        this.SigLibroId = 11; //guardamos estos indices para saber en que indice deben empezar a registrarse el resto de los libros.
        this.SigUsaId = 6; //Lo mismo para los usuarios. 
    }

    primerosLibros(){ //arreglo con los primeros libros, covirtiendolos en objetos de la clase Libros. 
        return [
            new Libro(1, "Orgullo y Prejuicio", "Jane Austen", 1813, "Romance de √âpoca", true),
            new Libro(2,  "1984", "George Orwell", 1949, "Ciencia ficci√≥n", true),
            new Libro(3, "Harry Potter", "J.K. Rowling", 1997, "Fantas√≠a", true),
            new Libro(4, "Rojo, Blanco y Sangre Azul", "Casey McQuiston", 2017, "Romance", true),
            new Libro(5, "Mujercitas", "Louisa May Alcott", 1868, "Ficci√≥n Hist√≥rica", true),
            new Libro(6, "Cumbres Borrascosas", "Emily Bront√´", 1847, "Novela G√≥tica", true),
            new Libro(7, "El arte de la guerra", "Sun Tzu", 1972, "Historia", true),
            new Libro(8, "El retrato de Dorian Gray", "Oscar Wilde", 1890, "Novela G√≥tica", true), 
            new Libro(9, "Historia de dos ciudades", "Charles Dickens", 1859, "Ficci√≥n Hist√≥rica", true),
            new Libro(10, "Crep√∫sculo", "Stephenie Meyer", 2005, "Romantasy", true),
        ]
    }

    
    primerosUsuarios(){//arreglo con los primeros usuarios, covirtiendolos en objetos de la clase Usuarios. 
        return [
            new Usuario(1, "Ana Casta√±eda", "ana@email.com"),
            new Usuario(2, "Carlos Hernandez", "carlos@email.com"),
            new Usuario(3, "Mar√≠a Rodr√≠guez", "maria@email.com"),
            new Usuario(4, "Juan P√©rez", "juan@email.com"),
            new Usuario(5, "Carla Miranda", "carla@email.com") 
        ]
    }

    //Se un nuevo libro con ID autoincremental y disponible por defecto
    agregarLibro(titulo, autor, a√±o, genero) {
        const nuevoLibro = new Libro(this.SigLibroId++, titulo, autor, a√±o, genero, true);
        this.libros.push(nuevoLibro); //se agrega el nuevo libro al array libros
        return nuevoLibro;
    }


    buscarLibro(criterio, valor) {//Busca libros seg√∫n un criterio espec√≠fico
        return this.libros.filter(libro => {
            // Convierte el criterio a min√∫sculas para la comparaci√≥n 
            switch(criterio.toLowerCase()) {
                case 'titulo': return libro.titulo.toLowerCase().includes(valor.toLowerCase()); //se usa el metodo includes para verificar 
                case 'autor': return libro.autor.toLowerCase().includes(valor.toLowerCase());
                case 'genero': return libro.genero.toLowerCase().includes(valor.toLowerCase());
                default: return false;
            }
        });
    }

    // Ordena los libros seg√∫n el criterio (t√≠tulo o a√±o) con burbuja
    ordenarLibros(criterio){
        const librosCopia = [...this.libros]; //se hace una copia para no alterar el array original 
        // Bucle externo para recorrer el arreglo librosCopia
        for(let i=0; i<librosCopia.length -1; i++){
            // Bucle interno para comparar elementos adyacentes
            for(let j=0; j<librosCopia.length -i -1; j++){
                let cambio = false;// variable bandera para indicar si se debe hacer un intercambio
                // Comparaci√≥n seg√∫n el criterio elegido
                if(criterio === 'titulo'){
                    // Compara los t√≠tulos por el alfabeto
                    cambio = librosCopia[j].titulo > librosCopia[j+1].titulo;
                } else if(criterio === 'a√±o'){
                    // Compara los a√±os, para dejar los antiguos primero 
                    cambio = librosCopia[j].a√±o > librosCopia[j+1].a√±o
                }
                // Si se cumple la condici√≥n, se intercambian los elementos

                if (cambio) {
                    [librosCopia[j], librosCopia[j+1]] = [librosCopia[j+1], librosCopia[j]];
                }

            }
        }
        return librosCopia;
    }
    
    // Devuelve una copia del arreglo de libros actual
    mostrarTodosLosLibros() {
        return [...this.libros]; // Se usa spread(...) para evitar modificar el array original

    }
    
    // Elimina un libro por su id
    borrarLibro(id){
        // Busca el √≠ndice del libro con el id especificado
        const index = this.libros.findIndex(libro => libro.id === id); 
        // Si se encuentra el libro se elimina del array y se decuelve. 
        if(index !== -1){
            return this.libros.splice(index, 1)[0]; 
        }
        return null;//devuelve null, en caos de que no 
    }
    // Registra un nuevo usuario con nombre y email
    registrarUsuario(nombre, email){
         // Crea un nuevo usuario con el siguiente id
        const nuevoUser = new Usuario(this.SigUsaId++, nombre, email); 
        //se agrega al array usuarios
        this.usuarios.push(nuevoUser);
        //devuelve el usuario nuevo 
        return nuevoUser; 
    }

    // Devuelve una copia del arreglo de usuarios actual
    mostrarTodosLosUsuarios() {
        return [...this.usuarios];
    }

    // Busca un usuario por su email
    buscarUsuario(email){
        return this.usuarios.find(usuario => usuario.email === email); 
    }

    // Elimina un usuario por su id
    borrarUsuario(id) {
        // Busca el √≠ndice del usuario con el id especificado

        const indice = this.usuarios.findIndex(usuario => usuario.id === id);
        // Si no se encuentra, devuelve false
        if (indice === -1) {
            return false;
        }
        // Si lo encuentraelimina al usuario y devuelve true
        this.usuarios.splice(indice, 1);
        return true;
    }

    prestarLibro(idLibro, idUser){//recibe como parametro el id del libro y del usuario
        //Busca el libro por su id
        const libro = this.libros.find(l => l.id === idLibro); 
        // Busca el usuario por su id
        const usuario = this.usuarios.find(u => u.id === idUser); 
        //Si no se encuentra el libro o el usuario, retorna false
        if(!libro || !usuario) return false;
        //Si el libro no est√° disponible, no se puede prestar
        if(!libro.disponible) return false; 
        
        //Se marca el libro como no disponible
        libro.disponible = false; 
        // Agrega el id del libro a la lista de libros prestados del usuario
        usuario.librosPrestados.push(idLibro); 
        // Retorna true indicando que el pr√©stamo fue exitoso
        return true;
    }

    devolverLibro(idLibro, idUser){
        // Busca el libro por su id
        const libro = this.libros.find(l => l.id === idLibro); 
        // Busca el usuario por su id
        const usuario = this.usuarios.find(u => u.id === idUser);
        
        // Si no se encuentra el libro o el usuario, retorna false
        if(!libro || !usuario) return false; 
        // Busca el √≠ndice del libro en la lista de libros prestados del usuario
        const libroIn = usuario.librosPrestados.indexOf(idLibro); 
        // Si el libro no est√° en la lista, no se puede devolver
        if (libroIn === -1) return false; 
        // Marca el libro como disponible
        libro.disponible = true; 
        // Elimina el libro de la lista de libros prestados del usuario
        usuario.librosPrestados.splice(libroIn, 1); 
        // Retorna true indicando que la devoluci√≥n fue exitosa
        return true;
    }

    generarReporteLibros(){
        // Total de libros en el sistema
        const totalLibros = this.libros.length; 
         // Cuenta cu√°ntos libros est√°n prestados (no disponibles)
        const librosPrestados = this.libros.filter(libro => !libro.disponible).length;
        // Inicializa un objeto para contar libros por g√©nero
        const librosPorGenero = {};
         // Recorre todos los libros para agrupar por g√©nero
        for (let i=0; i<this.libros.length; i++){
            const libro = this.libros[i]; 
            const genero = libro.genero;
            // Si el g√©nero no existe a√∫n en el objeto, lo inicializa
            if(librosPorGenero[genero] === undefined){//undefined verifica si ese genrro au no ha sido registrado en el objeto. 
                //si es asi lo marca como el primero 
                librosPorGenero[genero] = 1;
            }else{
                //si ya existe se incrementa el contador 
                librosPorGenero[genero] = librosPorGenero[genero] + 1;
            }
        }    
        //Encuentra el libro m√°s antiguo usando reducee
        const libroMasAntiguo = this.libros.reduce((min, libro) => libro.a√±o < min.a√±o ? libro:min, this.libros[0]);
        //Encuentra el libro m√°s nuevo usando reduce otra vez pero ahora con la l√≥gica inversa 
        const libroMasNuevo = this.libros.reduce((max, libro) => libro.a√±o < max.a√±o ? libro:max, this.libros[0]);
        
        // Devuelve un objeto con el resumen del estado de los libros
        return {
            totalLibros,
            librosPrestados,
            librosPorGenero,
            libroMasAntiguo, 
            libroMasNuevo,
        };
    }

    librosConPalabrasEnTitulo(){
        return this.libros.filter(libro => {
            // Divide el t√≠tulo en palabras con .split, y eliminando espacios con .trim
            const palabras = libro.titulo.trim().split(/\s+/);
            // Verifica que haya m√°s de una palabra
            // Y que todas las palabras est√©n compuestas solo por letras (incluye acentos y √±)
            return palabras.length > 1 && 
                   palabras.every(palabra => /^[a-zA-Z√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë]+$/.test(palabra));
        //Devuelve el mapeo solo con los titulos que cumplen con la condicion
        }).map(libro => libro.titulo);
    }

    calcularEstadistica() {
        // Extrae todos los a√±os de los libros
        const a√±os = this.libros.map(libro => libro.a√±o);
        // se calcula el promedio de los a√±os
        const promedio = a√±os.reduce((sum, a√±o) => sum + a√±o, 0)/a√±os.length;
        // SE crea un objeto para contar cu√°ntas veces aparece cada a√±o
        const frecuencia = a√±os.reduce((acc, a√±o) => {
            acc[a√±o] = (acc[a√±o] || 0) + 1;
            return acc;
        }, {});
        // Encuentra el a√±o que aparece con mayor frecuencia
        const a√±oMasFrecuente = Object.keys(frecuencia).reduce((a, b) => frecuencia[a] > frecuencia[b] ? a : b);
        //Ordena los a√±os de menor a mayor
        const a√±osOrdenados = [...a√±os].sort((a, b) => a - b);
        // Calcula la diferencia entre el a√±o m√°s reciente y el m√°s antiguo
        const diferencia = a√±osOrdenados[a√±osOrdenados.length - 1] - a√±osOrdenados[0];
        //Devuelve un resumen con todas estas metricas
        return {
            promedio: Math.round(promedio),
            a√±oMasFrecuente: parseInt(a√±oMasFrecuente),
            diferencia
        };

    }

    normalizarDatos(){
        // Recorre todos los libros y convierte sus t√≠tulos a may√∫sculas
        this.libros.forEach(libro => {
            libro.titulo = libro.titulo.toUpperCase();
        }); 
        // Recorre nuevamente los libros y elimina espacios al inicio y al final del t√≠tulo
        this.libros.forEach(libro => {
            libro.titulo = libro.titulo.trim(); 
        }); 
        // Recorre todos los usuarios y convierte sus correos electr√≥nicos a min√∫sculas
        this.usuarios.forEach(usuario =>{
            usuario.email = usuario.email.toLowerCase();
        }); 
        // Devuelve un mensaje indicando que la normalizaci√≥n fue exitosa
        return { mensaje: "Datos normalizados correctamente"}; 
    }
}

class Interfaz{
    constructor(sistema) {
        this.biblioteca = sistema;
    }
    //menu principal 
    menuPrincipal(){
        let opcion; 

        do{
            opcion = prompt(` üìúBiblioteca de Alejandr√≠aü™∂   
                1. Gesti√≥n de Libros
                2. Gesti√≥n de Usuarios
                3. Sistema de Pr√©stamos
                4. Reportes y Estad√≠sticas
                5. Normalizar Datos
                6. Salir
                Seleccionar una opci√≥n: `);

            switch(opcion) {
                case'1': this.menuLibros(); break;
                case'2': this.menuUsers(); break; 
                case'3': this.menuPrestamos(); break; 
                case'4': this.menuReportes(); break; 
                case'5': this.menuNormalizar(); break;
                case'6': alert('¬°Gracias por venir a la Biblioteca de Alejandr√≠aü™∂!')
                default: alert('Opci√≥n no v√°lida'); 
            }
        }while(opcion !== '6')
    }
    //Casa submenu con sus opciones 
    menuLibros(){
        let opcion; 

        do{
          opcion = prompt(`
            Gesti√≥n de Librosüìö
            
            1. Agregar libro
            2. Buscar libro
            3. Mostrar todos los libros
            4. Ordenar libros 
            5. Eliminar libro 
            6. Volver al men√∫ principal
            
            Selecciona una opci√≥n: `); 

            switch(opcion) {
                case'1': this.agregarLibro(); break;
                case'2': this.buscarLibro(); break; 
                case'3': this.mostrarTodosLosLibros(); break; 
                case'4': this.ordenarLibros(); break; 
                case'5': this.borrarLibro(); break; 
                case'6': return; 
                default: alert('Opci√≥n V√°lida');
            }
        }while(opcion !== '6')
    }

    menuUsers(){
        let opcion; 

        do{
            opcion= prompt(`
                Gestion de Usuarios üë§

                1. Registrar usuario
                2. Buscar usuario por email 
                3. Mostrar todos los usuarios
                4. Eliminar usuario
                5. Volver al men√∫ principal
                
                Selecciona una opci√≥n: `); 

                switch(opcion){
                    case'1': this.registrarUsuario(); break; 
                    case'2': this.buscarUsuario(); break; 
                    case'3': this.mostrarTodosLosUsuarios(); break; 
                    case'4': this.borrarUsuario(); break; 
                    case'5': return; 
                    default: alert('Opci√≥n no v√°lida');
                }
        }while (opcion !== '5');
    }

    menuPrestamos(){
        let opcion; 

        do {
            opcion = prompt(`
                Pr√©stamos üîÅ

                1. Registro de Pr√©stamos
                2. Registro de Devoluci√≥n
                3. Volver al men√∫ principal
                Selecciona una opci√≥n: `
            ); 

            switch(opcion){
                case'1': this.prestarLibro(); break; 
                case'2': this.devolverLibro(); break; 
                case'3': return; 
                default: alert('Opci√≥n no v√°lida'); 

            }

        }while (opcion !== '3');
    }

    menuReportes(){
        let opcion; 
        
        do{
            opcion = prompt(`
                Reportes y Est√°disticasüìà
                
                1. Generar reporte de libros
                2. Calcular estad√≠stcas 
                3. Libros con t√≠tulos de varias palabras.
                4. Volver al men√∫ principal
                Selecciona una opci√≥n: `); 

            switch(opcion){
                case'1': this.generarReporteLibros(); break; 
                case'2': this.calcularEstadistica(); break; 
                case'3': this.librosConPalabrasEnTitulo(); break; 
                case'4': return; 
                default: alert('Opcion no v√°lida');  
            }
        }while (opcion !== '4'); 
    }

    menuNormalizar(){
        let opcion; 

        do{
            opcion = prompt(`
                Normalizaci√≥n üìã
                1. Normalizar datos
                2. Volver al men√∫ principal
                Selecciona una opci√≥n: `); 

            switch(opcion) {
                case'1': this.normalizarDatos(); break; 
                case'2': return; 
                default: alert('Opci√≥n no v√°lida'); 
            }
        } while (opcion !== '2');
    }

    //Implementaci√≥n de los m√©todos para cada men√∫ 

   //M√©todos para Gesti√≥n de Libros 
   agregarLibro(){
       const titulo = prompt("Ingrese el t√≠tulo del libro: "); 
       const autor = prompt("Ingrese el autor del libro: "); 
       const a√±o = parseInt(prompt("Ingresa el a√±o de publicaci√≥n: ")); 
       const genero = prompt("Ingresa el g√©nero del libro: "); 

       if (titulo && autor && a√±o && genero){ //si est√°n todos los datos, se registra
          this.biblioteca.agregarLibro(titulo, autor, a√±o, genero); 
          alert("Libro agregado correctamente")
       }else {
        alert("Error: Todos los campos son obligatorios"); 
       }
    } 
   //se pide ingresar el cirterio, se verifica y luego se pide el valor de dicho criterio 
   buscarLibro(){
       const criterio = prompt("Buscar por: \n1. T√≠tulo\n2. Autor\n3. G√©nero\nSeleccione una opci√≥n:"); 
       let tipoB; 

       switch (criterio) {
           case'1': tipoB = 'titulo'; break;
           case'2': tipoB = 'autor'; break; 
           case'3': tipoB = 'genero'; break;
            default: alert("Opci√≥n no v√°lida"); break;
        }

        const valor = prompt(`Ingrese el ${tipoB} a buscar:`);
        const resultados = this.biblioteca.buscarLibro(tipoB, valor);

       if (resultados.length > 0) {
            let mensaje = `üîç Resultados de b√∫squeda (${resultados.length} encontrados):\n\n`;
            resultados.forEach(libro => {
                mensaje += `üìñ ${libro.titulo} - ${libro.autor} (${libro.a√±o})\n`;
                mensaje += `   G√©nero: ${libro.genero} | Estado: ${libro.disponible ? '‚úÖ Disponible' : '‚ùå Prestado'}\n\n`;
            });
            alert(mensaje);
        } else {
            alert("‚ùå No se encontraron libros con ese criterio");
        }
    }

    //Muestra todos los libros registrados 
    mostrarTodosLosLibros() {
        if (this.biblioteca.libros.length === 0) {
            alert("üìö No hay libros en la biblioteca");
            return;
        }
        
        let mensaje = "üìö LISTA COMPLETA DE LIBROS:\n\n";
        this.biblioteca.libros.forEach(libro => {
            mensaje += `ID: ${libro.id} | üìñ ${libro.titulo}\n`;
            mensaje += `   üë§ Autor: ${libro.autor} | üìÖ A√±o: ${libro.a√±o}\n`;
            mensaje += `   üè∑Ô∏è G√©nero: ${libro.genero} | Estado: ${libro.disponible ? '‚úÖ Disponible' : '‚ùå Prestado'}\n\n`;
        });
        
        alert(mensaje);
    }
    

    borrarLibro() {
        const id = parseInt(prompt("Ingrese el ID del libro a eliminar:"));
        const libroEliminado = this.biblioteca.borrarLibro(id);
        
        if (libroEliminado) {
            alert(`‚úÖ Libro "${libroEliminado.titulo}" eliminado correctamente`);
        } else {
            alert("‚ùå No se encontr√≥ un libro con ese ID");
        }
    }

    ordenarLibros() {
        const criterio = prompt("Ordenar por:\n1. T√≠tulo\n2. A√±o\nSeleccione una opci√≥n:");
        let tipoOrdenamiento;
        
        switch(criterio) {
            case '1': tipoOrdenamiento = 'titulo'; break;
            case '2': tipoOrdenamiento = 'a√±o'; break;
            default: 
                alert("‚ùå Opci√≥n no v√°lida");
                return;
        }
        
        const librosOrdenados = this.biblioteca.ordenarLibros(tipoOrdenamiento);
        let mensaje = `üìö LIBROS ORDENADOS POR ${tipoOrdenamiento.toUpperCase()}:\n\n`;
        librosOrdenados.forEach(libro => {
            mensaje += `üìñ ${libro.titulo} - ${libro.autor} (${libro.a√±o})\n`;
            });
        
        alert(mensaje);
    }
    
    

    //Metodos para el Men√∫ de Gesti√≥n de Usuarios

    registrarUsuario() {
        const nombre = prompt("Ingrese el nombre del usuario:");
        const email = prompt("Ingrese el email del usuario:");
        
        if (nombre && email) {
            this.biblioteca.registrarUsuario(nombre, email);
            alert("‚úÖ Usuario registrado correctamente!");
        } else {
            alert("‚ùå Error: Todos los campos son obligatorios");
        }
    }

    buscarUsuario() {
        const email = prompt("Ingrese el email del usuario a buscar:");
        const usuario = this.biblioteca.buscarUsuario(email);
        
        if (usuario) {
            let mensaje = `üë§ INFORMACI√ìN DEL USUARIO:\n\n`;
            mensaje += `Nombre: ${usuario.nombre}\n`;
            mensaje += `Email: ${usuario.email}\n`;
            mensaje += `ID: ${usuario.id}\n`;
            mensaje += `Libros prestados: ${usuario.librosPrestados.length}\n`;
            
            if (usuario.librosPrestados.length > 0) {
                mensaje += `\nüìö Libros prestados:\n`;
                usuario.librosPrestados.forEach(idLibro => {
                    const libro = this.biblioteca.libros.find(l => l.id === idLibro);
                    if (libro) {
                        mensaje += `   - ${libro.titulo}\n`;
                    }
                });
            }
            
            alert(mensaje);
        } else {
            alert("‚ùå No se encontr√≥ un usuario con ese email");
        }
    }

    mostrarTodosLosUsuarios() {
        if (this.biblioteca.usuarios.length === 0) {
            alert("üë• No hay usuarios registrados");
            return;
        }
        
        let mensaje = "üë• LISTA COMPLETA DE USUARIOS:\n\n";
        this.biblioteca.usuarios.forEach(usuario => {
            mensaje += `ID: ${usuario.id} | üë§ ${usuario.nombre}\n`;
            mensaje += `   üìß Email: ${usuario.email}\n`;
            mensaje += `   üìö Libros prestados: ${usuario.librosPrestados.length}\n\n`;
        });
        
        alert(mensaje);
    }

    borrarLibro() {
    // Mostrar todos los libros para que asi pueda indicar su id 
    if (this.biblioteca.libros.length === 0) {
        alert("‚ùå No hay libros para eliminar");
        return;
    }
    
    let listaLibros = "Seleccione el ID del libro a eliminar:\n\n";
    this.biblioteca.libros.forEach(libro => {
        const estado = libro.disponible ? "Disponible" : "Prestado";
        listaLibros += `ID: ${libro.id} - "${libro.titulo}" por ${libro.autor} (${estado})\n`;
    });
    
    const id = parseInt(prompt(listaLibros + "\nIngrese el ID:"));
    const libroEliminado = this.biblioteca.borrarLibro(id);
    
    if (libroEliminado) {
        alert(`‚úÖ Libro "${libroEliminado.titulo}" eliminado correctamente`);
    } else {
        alert("‚ùå No se encontr√≥ un libro con ese ID");
    }
}

    //M√©todos para Sistema de Pr√©stamos 

    prestarLibro() {
        //Verifica que si haya usuarios, o si no dar una alerta al respeto 
        if (this.biblioteca.usuarios.length === 0) {
            alert("‚ùå No hay usuarios registrados");
            return;
        }
        //Verifica que si haya libros
        if (this.biblioteca.libros.filter(l => l.disponible).length === 0) {
            alert("‚ùå No hay libros disponibles para prestar");
            return;
        }
        
        //Muestra todos los usuarios para que se seleccione quien va a hacer el prestamos
        let listaUsuarios = "Seleccione el ID del usuario:\n\n";
        this.biblioteca.usuarios.forEach(usuario => {
            listaUsuarios += `ID: ${usuario.id} - ${usuario.nombre}\n`;
        });
        
        const idUsuario = parseInt(prompt(listaUsuarios + "\nIngrese el ID del usuario:"));
        // Mostrar todos los libros disponibles
        const librosDisponibles = this.biblioteca.libros.filter(l => l.disponible);
        let listaLibros = "Seleccione el ID del libro a prestar:\n\n";
        librosDisponibles.forEach(libro => {
            listaLibros += `ID: ${libro.id} - ${libro.titulo} (${libro.autor})\n`;
        });
        
        const idLibro = parseInt(prompt(listaLibros + "\nIngrese el ID del libro:"));
        //Si el metodo es exitoso devolvera un true 
        const exito = this.biblioteca.prestarLibro(idLibro, idUsuario);
        
        if (exito) {
            alert("‚úÖ Libro prestado correctamente!");
        } else {
            alert("‚ùå Error: No se pudo realizar el pr√©stamo");
        }
      
    }

    devolverLibro() {
        //COn filter arroja solo los usuarios que tienen al menos un libro prestado
        const usuariosConPrestamos = this.biblioteca.usuarios.filter(u => u.librosPrestados.length > 0);
        //Si no hay prestamos entonces da la alerta y regresa
        if (usuariosConPrestamos.length === 0) {
            alert("‚ùå No hay pr√©stamos activos");
            return;
        }
        //Lista de usuarios que si tienen prestamo para que seleccione quien va a devolver un libro
        let listaUsuarios = "Seleccione el ID del usuario:\n\n";
        usuariosConPrestamos.forEach(usuario => {
            listaUsuarios += `ID: ${usuario.id} - ${usuario.nombre} (${usuario.librosPrestados.length} libros)\n`;
        });
        
        const idUsuario = parseInt(prompt(listaUsuarios + "\nIngrese el ID del usuario:"));
        const usuario = this.biblioteca.usuarios.find(u => u.id === idUsuario);
        
        if (!usuario || usuario.librosPrestados.length === 0) {
            alert("‚ùå Usuario no v√°lido o sin pr√©stamos");
            return;
        }
        
        // Mostrar libros prestados del usuario
        let listaLibros = "Seleccione el ID del libro a devolver:\n\n";
        usuario.librosPrestados.forEach(idLibro => {
            const libro = this.biblioteca.libros.find(l => l.id === idLibro);
            if (libro) {
                listaLibros += `ID: ${libro.id} - ${libro.titulo}\n`;
            }
        });
        //Pedirle que ingrese el id del que desea devolver 
        const idLibro = parseInt(prompt(listaLibros + "\nIngrese el ID del libro:"));
        //Devuelve un true si el metodo funciono bien 
        const exito = this.biblioteca.devolverLibro(idLibro, idUsuario);
        
        if (exito) {
            alert("‚úÖ Libro devuelto correctamente!");
        } else {
            alert("‚ùå Error: No se pudo realizar la devoluci√≥n");
        }
    }

    generarReporteLibros() {
        //Obtenemos el reporte general generado por el metodo que se encuentra en la clase biblioteca 
        const reporte = this.biblioteca.generarReporteLibros();
        //con esos datos mostramos un mensaje al usuario: 
        let mensaje = "üìä REPORTE DE BIBLIOTECA\n\n";
        mensaje += `üìö Total de libros: ${reporte.totalLibros}\n`;
        mensaje += `üìñ Libros prestados: ${reporte.librosPrestados}\n`;
        mensaje += `‚úÖ Libros disponibles: ${reporte.totalLibros - reporte.librosPrestados}\n\n`;
        //cantidad de libros por g√©nero 
        mensaje += "üè∑Ô∏è Libros por g√©nero:\n";
        for (const [genero, cantidad] of Object.entries(reporte.librosPorGenero)) {
            mensaje += `   ${genero}: ${cantidad} libros\n`;
        }
        //el libro mas antiguo y el m√°s nuevo. 
        mensaje += `\nüìÖ Libro m√°s antiguo: ${reporte.libroMasAntiguo.titulo} (${reporte.libroMasAntiguo.a√±o})\n`;
        mensaje += `üìÖ Libro m√°s nuevo: ${reporte.libroMasNuevo.titulo} (${reporte.libroMasNuevo.a√±o})`;
        
        alert(mensaje);
    }

    calcularEstadisticas() {
        //las estadisticas calculadas en biblioteca, las traemos 
        const estadisticas = this.biblioteca.calcularEstadisticas();
        //y se construye un mensaje mostrando los datos
        let mensaje = "üìà ESTAD√çSTICAS DE LA BIBLIOTECA\n\n";
        mensaje += `üìä Promedio de a√±os de publicaci√≥n: ${estadisticas.promedio}\n`;
        mensaje += `üìÖ A√±o de publicaci√≥n m√°s frecuente: ${estadisticas.a√±oMasFrecuente}\n`;
        mensaje += `‚è≥ Diferencia entre libro m√°s nuevo y m√°s antiguo: ${estadisticas.diferencia} a√±os`;
        
        alert(mensaje);
    }

    librosConPalabrasEnTitulo() {
        //Los titulos con multiples palabra sse obtienen 
        const libros = this.biblioteca.librosConPalabrasEnTitulo();
        //Si el metodo no devulve nada, muestra una alerta 
        if (libros.length === 0) {
            alert("‚ùå No se encontraron libros con t√≠tulos de m√∫ltiples palabras");
            return;
        }
        // se construye el mensaje con los titulos encontrados. 
        let mensaje = "üî§ LIBROS CON T√çTULOS DE M√öLTIPLES PALABRAS:\n\n";
        libros.forEach(titulo => {
            mensaje += `üìñ ${titulo}\n`;
        });
        
        alert(mensaje);
    }
    

    
}
//se crea una nueva instancoa de la clase Biblioteca(la principal)
const biblioteca = new Biblioteca();
//se crea una nueva instancia de la clase Interfaz, recibiendo como argumento, la instancia biblioteca, lo que permite que la interfaz acceda a los metodos y datos de la biblioteca. 
const interfaz = new Interfaz(biblioteca);
//se llama al metodo del men√∫ principal para correr el programa
interfaz.menuPrincipal();

 </script>
</body>
</html>
